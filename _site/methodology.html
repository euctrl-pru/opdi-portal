<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>OPDI - Methodology</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-61343306-1', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OPDI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./data.html"> 
<span class="menu-text">Data</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./concepts.html"> 
<span class="menu-text">Concepts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./methodology.html" aria-current="page"> 
<span class="menu-text">Methodology</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./roadmap.html"> 
<span class="menu-text">Roadmap</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./data-preview.html"> 
<span class="menu-text">Data Preview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#flight-list" id="toc-flight-list" class="nav-link active" data-scroll-target="#flight-list">Flight List</a></li>
  <li><a href="#flight-events" id="toc-flight-events" class="nav-link" data-scroll-target="#flight-events">Flight Events</a></li>
  <li><a href="#measurements" id="toc-measurements" class="nav-link" data-scroll-target="#measurements">Measurements</a></li>
  <li><a href="#acronyms_HEADER_LOA" id="toc-acronyms_HEADER_LOA" class="nav-link" data-scroll-target="#acronyms_HEADER_LOA">List of Acronyms</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Methodology</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The various methodologies used to extract <strong>flight lists</strong>, <strong>flight events</strong> and <strong>measurements</strong> from trajectory state vectors. The code is publically available on <a href="https://github.com/euctrl-pru/opdi">GitHub</a>.</p>
<section id="flight-list" class="level2">
<h2 class="anchored" data-anchor-id="flight-list">Flight List</h2>
<p>To construct the flight list the trajectory needs to be identified from the state vectors. In addition, one needs to assign the Aerodrome of Departure (ADEP) and Aerodrome of Destination (ADES). Based on the state vector source, the trajectory might already contain an identifier <code>id</code> and an ADEP and ADES. The various subsequent algorithms are considered iterative improvements.</p>
<table class="table">
<thead>
<tr class="header">
<th>Version</th>
<th>Improvements</th>
<th>Development date</th>
<th>Methodology</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>v0.0.1</td>
<td>Initial flight, ADEP and ADES identification algorithm.</td>
<td>November 2023</td>
<td><a href="https://www.opdi.aero/methodology#flight-list-methodology">Link</a></td>
</tr>
<tr class="even">
<td>v0.0.2</td>
<td>Second iteration flight, ADEP and ADES identification algorithm.</td>
<td>March 2024</td>
<td><a href="https://www.opdi.aero/methodology#flight-list-methodology">Link</a></td>
</tr>
</tbody>
</table>
<section id="flight-list-methodology" class="level4">
<h4 class="anchored" data-anchor-id="flight-list-methodology">Flight List Methodology</h4>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Flight List v0.0.1
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Object</strong>: Flight list</p>
<p><strong>Version tag</strong>: <code>flight_list_v0.0.1</code></p>
<p><strong>Data source(s)</strong>: OpenSky Network (OSN)</p>
<p><strong>Flight identification algorithm(s):</strong></p>
<p>Given the OSN state vectors, identifiers or <code>id</code>s are assigned in monthly batches. The statevectors are grouped per <code>icao24</code> and <code>callsign</code> value. Each group is subsequently split and assigned a <code>splitnumber</code> if it is detected that there is a gap in between subsequent state vectors larger than 30 minutes or if there is a gap of 10 minutes whilst the altitude is below 1km.</p>
<p>The resulting trajectories are given <code>id</code>s which consist of the SHA256 value of the <code>icao24</code> and <code>callsign</code> followed by the <code>splitnumber</code> and the <code>year</code> and <code>month</code> of the <code>event_time</code>. This is done to ensure uniqueness of the <code>id</code>.</p>
<p><strong>ADEP/ADES identification algorithm(s):</strong></p>
<p>To approximate the ADEP or ADES of a departing or arriving flight, coordinate grids are calculated for each airport with a radius of 10 km and a latitude/longitude step of 0.0001 degrees. For each point in the circular grid surrounding the airport, the distance to the Aerodrome Reference Point (ARP) is calculated.</p>
<p>The trajectories identified in the previous step are filtered to only retain state vectors with an altitude lower than 10,000 ft. Onto the latitude and longitude (rounded to 0.0001 degrees) of the remaining state vectors the airport coordinate grids are superimposed. Each state vector in the resulting data sets now indicates the various aerodromes the coordinates overlap with. If there are multiple aerodromes available, the minimal initial/final distance to the aerodrome indicates the most likely ADEP or ADES.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Flight List v0.0.2
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Object</strong>: Flight list</p>
<p><strong>Version tag</strong>: <code>flight_list_v0.0.2</code></p>
<p><strong>Data source(s)</strong>: OSN</p>
<p><strong>Flight identification algorithm(s):</strong></p>
<p>Given the OSN state vectors, identifiers or <code>id</code>s are assigned in monthly batches. The statevectors are grouped per <code>icao24</code> and <code>callsign</code> value. Each group is subsequently split and assigned a <code>splitnumber</code> if it is detected that there is a gap in between subsequent state vectors larger than 30 minutes or if there is a gap of 10 minutes whilst the altitude is below 1km.</p>
<p>The resulting trajectories are given <code>id</code>s which consist of the SHA256 value of the <code>icao24</code> and <code>callsign</code> followed by the <code>splitnumber</code> and the <code>year</code> and <code>month</code> of the <code>event_time</code>. This is done to ensure uniqueness of the <code>id</code>.</p>
<p><strong>ADEP/ADES identification algorithm(s):</strong></p>
<p>To approximate the ADEP or ADES of a departing or arriving flight, the method has been adapted from v0.0.1. Compared to last version, circular geospatial detection grids are now created using <a href="https://h3geo.org/">Uber H3 geospatial library</a> calculated around each airport with a radius of 30 NM and an h3 resolution of 7. The trajectories are filtered to only retain state vectors with an altitude lower than 40,000 ft to enable adequate detection of both arrivals and departures. For each lat/lon point of the trajectories a H3 tag is then determined to match with the H3 tags of the cells in the circular grid.</p>
<p>Onto the H3 tags of these state vectors the airport H3 grids are superimposed. Each state vector in the resulting data sets now indicates the various aerodromes the cells overlap with. If there are multiple aerodromes available, the minimal initial/final distance to the aerodrome indicates the most likely ADEP or ADES. Others are saved as potential ADEP <code>ADEP_P</code> and potential ADES <code>ADES_P</code>.</p>
</div>
</div>
</div>
</section>
</section>
<section id="flight-events" class="level2">
<h2 class="anchored" data-anchor-id="flight-events">Flight Events</h2>
<p>The flight events are extracted from the identified trajectories using different methods for the different <code>type</code>s of flight events.</p>
<table class="table">
<thead>
<tr class="header">
<th>Version</th>
<th>Improvements</th>
<th>Development date</th>
<th>Methodology</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>v0.0.1</td>
<td>Initial flight event extraction algorithm.</td>
<td>November 2023</td>
<td><a href="https://www.opdi.aero/methodology#flight-event-methodology">Link</a></td>
</tr>
<tr class="even">
<td>v0.0.2</td>
<td>Second iteration flight event extraction algorithm.</td>
<td>May 2024</td>
<td><a href="https://www.opdi.aero/methodology#flight-event-methodology">Link</a></td>
</tr>
</tbody>
</table>
<section id="flight-events-methodology" class="level4">
<h4 class="anchored" data-anchor-id="flight-events-methodology">Flight Events Methodology</h4>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Flight Events v0.0.1
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Object</strong>: Flight Events</p>
<p><strong>Version tag</strong>: <code>flight_events_v0.0.1</code></p>
<p><strong>Data source(s)</strong>: OSN</p>
<p><strong>Flight event type(s)</strong>:</p>
<p>Currently the following flight event types are extracted:</p>
<table class="table">
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>Event type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>level-start</code></td>
<td>The start of a level segment.</td>
</tr>
<tr class="even">
<td><code>level-end</code></td>
<td>The end of a level segment.</td>
</tr>
<tr class="odd">
<td><code>top-of-descent</code></td>
<td>The top-of-descent.</td>
</tr>
<tr class="even">
<td><code>top-of-climb</code></td>
<td>The top-of-climb.</td>
</tr>
<tr class="odd">
<td><code>take-off</code></td>
<td>The take-off.</td>
</tr>
<tr class="even">
<td><code>landing</code></td>
<td>The landing.</td>
</tr>
<tr class="odd">
<td><code>first-xing-fl50/70/100/245</code></td>
<td>The first crossing of the flight level (FL) 50/70/100/245 during flight.</td>
</tr>
<tr class="even">
<td><code>last-xing-fl50/70/100/245</code></td>
<td>The last crossing of the flight level (FL) 50/70/100/245 during flight.</td>
</tr>
</tbody>
</table>
<p><strong>Flight event algorithm(s):</strong></p>
<p><em>Phase derivations</em></p>
<p>Using <a href="https://openap.dev/">OpenAP - The Open Model for Aircraft Performance and Emissions</a> by <a href="https://junzis.com/">Dr.&nbsp;Junzi Sun</a> of the TU Delft, the state vectors of each flight were assessed and classified into various phases (<code>GR</code> = Ground phase, <code>LVL</code> = Level segment phase, <code>CR</code> = Cruise phase, <code>DE</code> = Descent phase, <code>CL</code> = Climb phase). Using this the events are identified in each flight as follows:</p>
<ul>
<li><code>level-start</code>: The first state vector in each level segment phase (<code>LVL</code>).</li>
<li><code>level-end</code>: The last state vector in each level segment phase (<code>LVL</code>).</li>
<li><code>top-of-climb</code>: The first state vector of the first cruise phase (<code>CR</code>).</li>
<li><code>top-of-descent</code>: The last state vector of the last cruise phase (<code>CR</code>).</li>
<li><code>take-off</code>: The first state vector of the climb phase (<code>CL</code>) after a ground phase (<code>GND</code>).</li>
<li><code>landing</code>: The first state vector of the ground phase (<code>GND</code>) after a descent phase (<code>DE</code>).</li>
</ul>
<p><em>Crossings</em></p>
<p>For each crossing of the respective flight levels (FL50/70/100/245) the algorithm is as follows:</p>
<ol type="1">
<li>A smooth average flight level is calculated for each state vector.<br>
</li>
<li>The flight values are compared between each subsequent state vector.</li>
</ol>
<p>The first time it crosses a flight level of interest, the crossing state vector is recorded as a <code>first-xing</code> event. The last time it crosses a flight level of interest, the crossing state vector is recorded as a <code>last-xing</code> event.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Flight Events v0.0.2
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Object</strong>: Flight Events</p>
<p><strong>Version tag</strong>: <code>flight_events_v0.0.2</code></p>
<p><strong>Data source(s)</strong>: OSN</p>
<p><strong>Flight event type(s)</strong>:</p>
<p>Currently the following flight event types are extracted:</p>
<table class="table">
<thead>
<tr class="header">
<th>Event type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>level-start</code></td>
<td>The start of a level segment.</td>
</tr>
<tr class="even">
<td><code>level-end</code></td>
<td>The end of a level segment.</td>
</tr>
<tr class="odd">
<td><code>top-of-descent</code></td>
<td>The top-of-descent.</td>
</tr>
<tr class="even">
<td><code>top-of-climb</code></td>
<td>The top-of-climb.</td>
</tr>
<tr class="odd">
<td><code>take-off</code></td>
<td>The take-off.</td>
</tr>
<tr class="even">
<td><code>landing</code></td>
<td>The landing.</td>
</tr>
<tr class="odd">
<td><code>first-xing-fl50/70/100/245</code></td>
<td>The first crossing of the flight level (FL) 50/70/100/245 during flight.</td>
</tr>
<tr class="even">
<td><code>last-xing-fl50/70/100/245</code></td>
<td>The last crossing of the flight level (FL) 50/70/100/245 during flight.</td>
</tr>
<tr class="odd">
<td><code>entry-runway</code></td>
<td>The entry of a runway at an airport. Additional identifiable <a href="https://www.openstreetmap.org/">OpenStreetMap</a> information of the runway is embedded in the <code>info</code> field in the form of a json.</td>
</tr>
<tr class="even">
<td><code>exit-runway</code></td>
<td>The exit of a runway at an airport. Additional identifiable <a href="https://www.openstreetmap.org/">OpenStreetMap</a> information of the runway is embedded in the <code>info</code> field in the form of a json.</td>
</tr>
<tr class="odd">
<td><code>entry-taxiway</code></td>
<td>The entry of a taxiway at an airport. Additional identifiable <a href="https://www.openstreetmap.org/">OpenStreetMap</a> information of the runway is embedded in the <code>info</code> field in the form of a json.</td>
</tr>
<tr class="even">
<td><code>exit-taxiway</code></td>
<td>The exit of a taxiway at an airport. Additional identifiable <a href="https://www.openstreetmap.org/">OpenStreetMap</a> information of the runway is embedded in the <code>info</code> field in the form of a json.</td>
</tr>
<tr class="odd">
<td><code>entry-parking_position</code></td>
<td>The entry of a parking position at an airport. Additional identifiable <a href="https://www.openstreetmap.org/">OpenStreetMap</a> information of the runway is embedded in the <code>info</code> field in the form of a json.</td>
</tr>
<tr class="even">
<td><code>exit-parking_position</code></td>
<td>The exit of a parking position at an airport. Additional identifiable <a href="https://www.openstreetmap.org/">OpenStreetMap</a> information of the runway is embedded in the <code>info</code> field in the form of a json.</td>
</tr>
</tbody>
</table>
<p><strong>Flight event algorithm(s):</strong></p>
<p><em>Phase derivations</em></p>
<p>Using <a href="https://openap.dev/">OpenAP - The Open Model for Aircraft Performance and Emissions</a> by <a href="https://junzis.com/">Dr.&nbsp;Junzi Sun</a> of the TU Delft, the state vectors of each flight were assessed and classified into various phases (<code>GR</code> = Ground phase, <code>LVL</code> = Level segment phase, <code>CR</code> = Cruise phase, <code>DE</code> = Descent phase, <code>CL</code> = Climb phase). Using this the events are identified in each flight as follows:</p>
<ul>
<li><code>level-start</code>: The first state vector in each level segment phase (<code>LVL</code>).</li>
<li><code>level-end</code>: The last state vector in each level segment phase (<code>LVL</code>).</li>
<li><code>top-of-climb</code>: The first state vector of the first cruise phase (<code>CR</code>).</li>
<li><code>top-of-descent</code>: The last state vector of the last cruise phase (<code>CR</code>).</li>
<li><code>take-off</code>: The first state vector of the climb phase (<code>CL</code>) after a ground phase (<code>GND</code>).</li>
<li><code>landing</code>: The first state vector of the ground phase (<code>GND</code>) after a descent phase (<code>DE</code>).</li>
</ul>
<p>This algorithm has been adapted in this version to a native PySpark version for processing speed improvements.</p>
<p><em>Crossings</em></p>
<p>For each crossing of the respective flight levels (FL50/70/100/245) the algorithm is as follows:</p>
<ol type="1">
<li>A smooth average flight level is calculated for each state vector.<br>
</li>
<li>The flight values are compared between each subsequent state vector.</li>
</ol>
<p>The first time it crosses a flight level of interest, the crossing state vector is recorded as a <code>first-xing</code> event. The last time it crosses a flight level of interest, the crossing state vector is recorded as a <code>last-xing</code> event.</p>
<p><em>Airport events</em></p>
<p>For each airport element (runway/taxiway/parking position) that we detect entry and exit in, the geographic information has been retrieved from <a href="https://www.openstreetmap.org/">OpenStreetMap</a>. This information has been processed and made a geospatial grid using <a href="https://h3geo.org/">Uber H3</a>. Following this, the trajectories have been matched to these grid cells at resolution 12.</p>
<p>A separate open source project is being developed to use this for small scale applications. See <a href="https://github.com/euctrl-pru/HexAeroPy">HexAero</a>.</p>
</div>
</div>
</div>
</section>
</section>
<section id="measurements" class="level2">
<h2 class="anchored" data-anchor-id="measurements">Measurements</h2>
<table class="table">
<thead>
<tr class="header">
<th>Version</th>
<th>Improvements</th>
<th>Development date</th>
<th>Methodology</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>v0.0.1</td>
<td>Initial measurement calculation algorithm.</td>
<td>November 2023</td>
<td><a href="https://www.opdi.aero/methodology#measurements-methodology">Link</a></td>
</tr>
<tr class="even">
<td>v0.0.2</td>
<td>Second iteration measurement calculation algorithm.</td>
<td>June 2024</td>
<td><a href="https://www.opdi.aero/methodology#measurements-methodology">Link</a></td>
</tr>
</tbody>
</table>
<section id="measurement-methodology" class="level4">
<h4 class="anchored" data-anchor-id="measurement-methodology">Measurement Methodology</h4>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Measurements v0.0.1
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Object</strong>: Measurements</p>
<p><strong>Version tag</strong>: <code>measurements_v0.0.1</code></p>
<p><strong>Data source(s)</strong>: OpenSky Network (OSN)</p>
<p><strong>Measurement type(s)</strong>:</p>
<p>Currently the following measurements are determined:</p>
<table class="table">
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>Measurement type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Distance Flown (NM)</code></td>
<td>The cumulative distance flown up until this this event since the aircraft started its’ trajectory (at time <code>first_seen</code>).</td>
</tr>
</tbody>
</table>
<p><strong>Measurement algorithm(s):</strong></p>
<p><em>Distance Flown (NM)</em></p>
<p>The <code>Distance flown (NM)</code> is calculated between each subsequent state vector using the great circle distance. The unit is nautic miles (NM). This segment distance is then summed cumulatively for each state vector since the first state vector (at time <code>first_seen</code>). This determined flown distance in nautic miles is then taken as measurement when identifying a flight event.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Measurements v0.0.2
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Object</strong>: Measurements</p>
<p><strong>Version tag</strong>: <code>measurements_v0.0.2</code></p>
<p><strong>Data source(s)</strong>: OpenSky Network (OSN)</p>
<p><strong>Measurement type(s)</strong>:</p>
<p>Currently the following measurements are determined:</p>
<table class="table">
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>Measurement type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Distance Flown (NM)</code></td>
<td>The cumulative distance flown in nautic miles up until this this event since the aircraft started its’ trajectory (at time <code>first_seen</code>).</td>
</tr>
<tr class="even">
<td><code>Time passed (s)</code></td>
<td>The cumulative time passed in seconds up until this this event since the aircraft started its’ trajectory (at time <code>first_seen</code>).</td>
</tr>
</tbody>
</table>
<p><strong>Measurement algorithm(s):</strong></p>
<p><em>Distance Flown (NM)</em></p>
<p>The <code>Distance flown (NM)</code> is calculated between each subsequent state vector using the great circle distance. The unit is nautic miles (NM). This segment distance is then summed cumulatively for each state vector since the first state vector (at time <code>first_seen</code>). This determined flown distance in nautic miles is then taken as measurement when identifying a flight event.</p>
<p><em>Time passed (s)</em></p>
<p>The <code>Time passed (s)</code> is calculated between each subsequent state vector by subtracting the timestamps and taking a cumulative sum. The unit is seconds (s).</p>
</div>
</div>
</div>


</section>
</section>
<section id="acronyms_HEADER_LOA" class="level1 loa">
<h1 class="loa">List of Acronyms</h1>
<dl>
<dt><span id="acronyms_ADEP">ADEP</span></dt>
<dd>
Aerodrome of Departure
</dd>
<dt><span id="acronyms_ADES">ADES</span></dt>
<dd>
Aerodrome of Destination
</dd>
<dt><span id="acronyms_ARP">ARP</span></dt>
<dd>
Aerodrome Reference Point
</dd>
<dt><span id="acronyms_OSN">OSN</span></dt>
<dd>
OpenSky Network
</dd>
</dl>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>